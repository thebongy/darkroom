import pygame
from pygame.locals import *
import sys
import json

SPEED = 10 # No of pixels the player walks per frame

def load_image(fullname, colorkey=None):
    try:
        image = pygame.image.load(fullname)
    except pygame.error:
        print ('Cannot load image:', fullname)
        raise SystemExit(str(geterror()))
    image = image.convert()
    if colorkey is not None:
        if colorkey is -1:
            colorkey = image.get_at((0,0))
        image.set_colorkey(colorkey, RLEACCEL)
    return image, image.get_rect()

def get_tile(tile_id, width):
    '''
    A function which magically returns the tile coordinates based on the tile ID generated by tiled.
    FYI, tiled counts map IDs like this:
    0  1  2  3  4
    5  6  7  8  9
    ... and so on

    The math used below should be self-explanatory. If not, ignore and assume it works xD.
    '''
    y = tile_id / width
    x = tile_id % width
    return x*32,y*32

def load_level(fl):
    '''
    Function to load a map into a surface object, and also build a rect of walls and grounds
    so that the player can use these and calculate collision points in the future.
    '''
    objects = {'Ground':[],'Wall':[]} #Needs to be extended to all objects

    with open(fl) as data_file:
        data = json.load(data_file)
    
    tiles, tiles_rect = load_image('res/tilesets/'+data['tilesets'][0]['image']) # The Tileset for our map
    tiles_w = tiles_rect.size[0] / 32 # Calculate no of tiles in a single row of the tileset
    width, height = data['width']*32, data['height']*32 # Calculate width and height of map built in tiled
    
    level = pygame.Surface((width,height))

    for layer in data['layers']:
        if layer['name'] in ('Ground', 'Wall'): # We need to make similar loops for doors, keys, and other components!!
            l_w = layer['width'] # Width of layer (Should be mostly equal to data['width'], but just in case)
            level_tiles = layer['data'] # The list of tile IDs generated from tiled
            for tile in range(len(level_tiles)):
                if level_tiles[tile] != 0: # If the tile is a non empty tile
                    pos = get_tile(tile,l_w) # Get the position to blit the tile on the map

                    # Get the tile from the tileset, and blit it on pos: (Refer to syntax of blit if confused)
                    # ALso note that the '-1' is to decrement the ID generated by Tiled, as it appears to have a Bug
                    # and outputs IDs which are 1 more than the real ID
                    tile_rect = level.blit(tiles, pos, get_tile(level_tiles[tile]-1, tiles_w)+(32,32))
                    
                    #Lastly add a rect object of the tile to the corresponding object
                    objects[layer['name']].append(tile_rect)
    return level, objects                

class Player(pygame.sprite.Sprite):
    def __init__(self,level,start_pos):
        pygame.sprite.Sprite.__init__(self)
        self.p_tiles = [[],[],[],[]] # UP, DOWN, LEFT, RIGHT!
        # PHOTOSHOP SKILLS -
        '''
        The hero sprites is an animation with 6 images. By default all of these are facing right. But we
        require images for up, left, bottom facing positions also. The below code does the required
        transformations to obtain images for each direction.
        '''
        
        # Images for hero facing right
        for i in range(1,7):
            self.p_tiles[3].append(load_image('res/tilesets/player'+str(i)+'.png')) # The default images face to the right
        
        #Images for hero facing left
        for i in range(6):
            self.p_tiles[2].append(pygame.transform.flip(self.p_tiles[3][i],1,0)) # Flip the right images
        
        #Images for hero facing up
        for i in range(6):
            self.p_tiles[0].append(pygame.transform.rotate(self.p_tiles[3][i],90)) # Rotate the right images 90 degrees counter-clockwise
        
        #Images for hero facing down
        for i in range(6):
            self.p_tiles[1].append(pygame.transform.flip(self.p_tiles[0][i],0,1)) # Flip the up images
        
        self.images,self.rect = self.p_tiles[0][0] # Set default as hero facing straight
        self.rect.topleft = start_pos # Starting position of hero on map. (The coordinates of the beginning door)
        # 0-UP 1-DOWN 2-LEFT 3-RIGHT
        self.move_state = 0
        self.direction = 0
        self.objects = level[1] # Ground and Wall Rects in a dict of lists

    def walk(self,direction):
        # 0-UP 1-DOWN 2-LEFT 3-RIGHT
        # Based on direction, find out the offset  coordinates to move by
        if direction == 0:
            move = (0,SPEED)
        elif direction == 1:
            move = (0,-SPEED)
        elif direction == 2:
            move = (-SPEED,0)
        elif direction == 3:
            move = (SPEED,0)

        # Find New position
        newpos = self.rect.move(move)

        # See if new position collides with a wall
        for wall in self.objects['Wall']:
            if newpos.colliderect(wall):
                return False
        
        # If the direction is same as the previous direction, move to the neext animation photo
        if direction == self.direction:
            self.move_state += 1
        else:
            self.move_state = 0 # If direction changes start from 0th move state
        self.rect = newpos
        self.image = self.p_tiles[direction][move_state]
    
    def stationary(self):
        # Stand straight, but face in the previous moved direction only.
        self.move_state = 0
        self.image = self.p_tiles[direction][move_state]

def main():
    pygame.init()
    screen = pygame.display.set_mode((800,600))
    pygame.display.set_caption('darkroom beta')
    
    level_1 = load_level('res/map/level.json')
    screen.blit(level_1[0], (0,0))

    pygame.display.flip()

    clock = pygame.time.Clock()

    game_running = True

    while game_running:
        clock.tick(60)
        for event in pygame.event.get():
            if event.type == QUIT:
                game_running = False


main()



